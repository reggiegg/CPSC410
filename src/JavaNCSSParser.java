// Number of methods per class
// Average method length per class (Sum method length) / num methods

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * JavaNCSSParser parses metrics from an XML file that are generated by JavaNCSS
 * @param xmlFile the JavaNCSS XML file to be parsed.
 * @return a list of JavaNCSSClassMetrics
 * @author Jeremy
 */
public class JavaNCSSParser {
	
	/**
	 * Parses metrics from an XML file generated by JavaNCSS
	 * @param xmlFile generated by JavaNCSS
	 * @return JavaNCSSMetrics object containing the metrics
	 */
	public JavaNCSSMetrics getJavaNCSSMetrics(File xmlFile) {
		List<JavaNCSSClassMetric> metricsList = null;
		try {
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			
			// convert the xml file to a format that can be parsed
			Document doc = dBuilder.parse(xmlFile);
			
			// normalize the doc to avoid complications with line breaks
			doc.getDocumentElement().normalize();
			
			// get all method elements within the xml file
			NodeList methodList = doc.getElementsByTagName("function");
			
			HashMap<String, ClassInfo> classesMap = new HashMap<String, ClassInfo>();
			
			// go through all methods, and pull out the relevant metrics
			for (int methodIndex = 0; methodIndex < methodList.getLength(); methodIndex++) {
				Node methodNode = methodList.item(methodIndex);
				
				if (methodNode.getNodeType() != Node.ELEMENT_NODE) {
					continue;
				}
				Element methodElement = (Element) methodNode;
				
				// get the number "Non Commenting Source Statements" contained within the method
				String methodNCSSText = methodElement.getElementsByTagName("ncss").item(0).getTextContent();
				int methodNCSS = 0;
				try {
					methodNCSS = Integer.valueOf(methodNCSSText);
				} catch (NumberFormatException e) {
					e.printStackTrace();
					break;
				}
				
				// get the "Code Complexity Number / McCabe Metric" of the method
				String methodCCNText = methodElement.getElementsByTagName("ccn").item(0).getTextContent();
				int methodCCN = 0;
				try {
					methodCCN = Integer.valueOf(methodCCNText);
				} catch (NumberFormatException e) {
					e.printStackTrace();
					break;
				}
				
				// get the full method name
				String methodName = methodElement.getElementsByTagName("name").item(0).getTextContent();
				
				// parse the class name from the full method name, discard the rest
				methodName = methodName.substring(0, methodName.indexOf("("));
				String qualifiedClassName = methodName.substring(0, methodName.lastIndexOf("."));
				String className = qualifiedClassName.substring(qualifiedClassName.lastIndexOf(".") + 1, qualifiedClassName.length());
				
				// find the class info object if it already exists in the map
				ClassInfo existingClassInfo = classesMap.get(qualifiedClassName);
				
				// if the class does not yet exist in the map then create a 
				// new map entry, otherwise add the new method info
				if (existingClassInfo == null) {
					ClassInfo newClass = new ClassInfo(className);
					newClass.addMethod(methodNCSS, methodCCN);
					classesMap.put(qualifiedClassName, newClass);
				} else {
					existingClassInfo.addMethod(methodNCSS, methodCCN);
				}
			}
			// create a new class metrics list from the hash map
			metricsList = createClassMetricsList (classesMap);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (SAXException e) {
			e.printStackTrace();
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		}
		return new JavaNCSSMetrics(metricsList);
	}
	
	/**
	 * Convert the classesInfo HashMap into a list of JavaNCSSClassMetrics
	 * @param classesMap a map of ClassInfo objects identified by class name
	 * @return a list of JavaNCSSClassMetrics
	 */
	private List<JavaNCSSClassMetric> createClassMetricsList (HashMap<String, ClassInfo> classesMap) {
		List<JavaNCSSClassMetric> classesList = new ArrayList<JavaNCSSClassMetric>();
		Iterator<Entry<String, ClassInfo>> classInfoIter = classesMap.entrySet().iterator();
		
		while (classInfoIter.hasNext()) {
			Map.Entry<String, ClassInfo> classInfoEntry = 
					(Map.Entry<String, ClassInfo>) classInfoIter.next();
			String qualifiedClassName = classInfoEntry.getKey().toString();
			ClassInfo classInfo = (ClassInfo)classInfoEntry.getValue();
			String className = classInfo.getClassName();
			int numMethods = classInfo.getNumMethods();
			float averageMethodLength = classInfo.getAverageMethodLength();
			int complexityNumber = classInfo.getComplexity();
			float complexityDensity = classInfo.getComplexityDensity();
			
			JavaNCSSClassMetric classMetric = 
					new JavaNCSSClassMetric(qualifiedClassName, className, 
							numMethods, averageMethodLength, complexityNumber, 
							complexityDensity);
			classesList.add(classMetric);
		}
		
		return classesList;
	}
	
	/**
	 * Internal class used by the JavaNCSSParser. ClassInfo objects are used in a hash table, and are
	 * associated with a particular class name as the key.
	 * @author Jeremy
	 */
	private class ClassInfo {
		private String className;
		private int numMethods;
		private int methodLengthSum;
		private int complexitySum;
		
		public ClassInfo (String className) {
			this.className = className;
			numMethods = 0;
			methodLengthSum = 0;
			complexitySum = 0;
		}
		
		/**
		 * Add another set of method metrics for a class. 
		 * @param methodLength The NCSS value for a given method.
		 * @param methodComplexity The Code Complexity Number (CCN) for
		 * a given method.
		 */
		public void addMethod(int methodLength, int methodComplexity) {
			numMethods++;
			this.methodLengthSum += methodLength;
			this.complexitySum += methodComplexity;
		}
		
		/**
		 * @return The simple class name
		 */
		public String getClassName() {
			return className;
		}
		
		/**
		 * @return The average method length for the methods in the class
		 */
		public float getAverageMethodLength() {
			return ((float)methodLengthSum)/numMethods;
		}
		
		/**
		 * @return The number of methods contained within a class
		 */
		public int getNumMethods() {
			return numMethods;
		}
		
		/**
		 * @return The code complexity number (CCN or McCabe Metric) for the class
		 */
		public int getComplexity() {
			return complexitySum;
		}
		
		/**
		 * @return The code complexity density (CCN / Total NCSS Method Sum)
		 */
		public float getComplexityDensity() {
			return ((float)complexitySum / methodLengthSum);
		}
	}
}
